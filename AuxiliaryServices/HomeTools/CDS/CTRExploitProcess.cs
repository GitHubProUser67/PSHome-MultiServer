using SonyEdge;
using CustomLogger;
using MultiServerLibrary.Extension;
using HomeTools.Crypto;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Security;
using System;
using System.Linq;
using System.Threading.Tasks;
using EndianTools;

namespace HomeTools.CDS
{
    public class CTRExploitProcess
    {
        public static bool UseHCDBBruteforceShortcut = false; // Uses the BC CTR handling, known to match the Home method in most cases, set to false for full accuracy.

        private static readonly byte[] XMLFirst8BytesHeaderWithJunk = new byte[] { 0xEF, 0xBB, 0xBF, 0x3C, 0x3F, 0x78, 0x6D, 0x6C };
        private static readonly byte[] XMLFirst8BytesHeader = new byte[] { 0x3C, 0x3F, 0x78, 0x6D, 0x6C, 0x20, 0x76, 0x65 };
        private static readonly byte[] XMLFirst8BytesSceneListTag = new byte[] { 0x3C, 0x53, 0x43, 0x45, 0x4E, 0x45, 0x4C, 0x49 };
        private static readonly byte[] BARFirst8BytesBigEndianLeanZlibHeader = new byte[] { 0xAD, 0xEF, 0x17, 0xE1, 0x01, 0x00, 0x00, 0x02 };
        private static readonly byte[] BARFirst8BytesLittleEndianLeanZlibHeader = new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x02, 0x00, 0x00, 0x01 };
        private static readonly byte[] BARFirst8BytesLittleEndianHeader = new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x00, 0x00, 0x00, 0x01 };
        private static readonly byte[] BARFirst8BytesBigEndianEquivHeader = new byte[] { 0xAD, 0xEF, 0x17, 0xE1, 0x01, 0x00, 0x00, 0x01 };
        private static readonly byte[] BARFirst8BytesLittleEndianEquivHeader = new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x01, 0x00, 0x00, 0x01 };
        private static readonly byte[] XMLFirst8BytesHeaderNAV1 = new byte[] { 0x3C, 0x58, 0x4D, 0x4C, 0x3E, 0x0D, 0x0A, 0x20 };
        private static readonly byte[] XMLFirst8BytesHeaderNAV2 = new byte[] { 0x3C, 0x58, 0x4D, 0x4C, 0x3E, 0x0A, 0x20, 0x20 };
        private static readonly byte[] First6BytesHCDB = new byte[] { 0x73, 0x65, 0x67, 0x73, 0x01, 0x05 };

        public static byte[] ProcessExploit(byte[] CipherTextReference, byte[] EncryptedFileBytes, int mode, ushort cdnMode)
        {
            byte[] ProcessedFileBytes = null;
            byte[] GuessedIV = null;
            byte[] key;

            switch (cdnMode)
            {
                case 2:
                    key = ToolsImplementation.HDKBlowfishKey;
                    break;
                case 1:
                    key = ToolsImplementation.BetaBlowfishKey;
                    break;
                default:
                    key = ToolsImplementation.BlowfishKey;
                    break;
            }

            switch (mode)
            {
                case 1: // HCDB
                    ProcessedFileBytes = BruteforceHCDB(CipherTextReference, EncryptedFileBytes, First6BytesHCDB, key);
                    break;
                case 2: // BAR.
                    ProcessedFileBytes = CheckBARResult(EncryptedFileBytes, CipherTextReference, ProcessECBBuffer(XORBytes(CipherTextReference, BARFirst8BytesBigEndianLeanZlibHeader), key), key);
                    break;
                default: // XML
                    foreach (byte[] header in new byte[][] { XMLFirst8BytesHeaderWithJunk, XMLFirst8BytesHeader, XMLFirst8BytesSceneListTag, XMLFirst8BytesHeaderNAV1, XMLFirst8BytesHeaderNAV2 })
                    {
                        GuessedIV = ProcessECBBuffer(XORBytes(CipherTextReference, header), key);
                        if (GuessedIV != null)
                        {
                            ProcessedFileBytes = CheckAndFindResult(EncryptedFileBytes, GuessedIV, key);
                            if (ProcessedFileBytes != null)
                                break;
                        }
                    }

                    break;
            }

            return ProcessedFileBytes;
        }

        private static byte[] BruteforceHCDB(byte[] CipherTextReference, byte[] EncryptedFileBytes, byte[] ReferencePlainTextPart, byte[] key)
        {
            byte[] result = null;

            foreach (byte firstByte in Enumerable.Range(0, 256).Select(v => (byte)v))
            {
                // Process Environment.ProcessorCount patherns at a time, removing the limit is not tolerable as CPU usage goes way too high.
                Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = Utils.ThreadLimiter.NumOfThreadsAvailable }, (secondByte, stateInner) =>
                {
                    byte[] GuessedNumOfSegments = new byte[] { (byte)firstByte, (byte)(byte.MaxValue - secondByte) };
                    byte[] ReferencePlainText = ByteUtils.CombineByteArray(ReferencePlainTextPart, GuessedNumOfSegments);
#if DEBUG
                    LoggerAccessor.LogInfo("[CDS] - BruteforceHCDB - Current PlainText Value - {0}", ReferencePlainText.ToHexString());
#endif
                    byte[] GuessedIV = ProcessECBBuffer(XORBytes(CipherTextReference, ReferencePlainText), key);

                    if (GuessedIV != null)
                    {
                        byte[] ProcessedFileBytes = CheckHCDBResult(EncryptedFileBytes, GuessedIV, key, EndianAwareConverter.ToUInt16(GuessedNumOfSegments, Endianness.LittleEndian, 0));

                        if (ProcessedFileBytes != null)
                        {
                            // Store result and stop all threads
                            result = ProcessedFileBytes;
                            stateInner.Stop();
                        }
                    }
                });

                // Check if result was found and break out of the outer loop if so
                if (result != null)
                    break;
            }

            return result;
        }

        private static byte[] CheckAndFindResult(byte[] EncryptedFileBytes, byte[] GuessedIV, byte[] key)
        {
            byte[] TestFileBytes = ToolsImplementation.ProcessCrypt_Decrypt(EncryptedFileBytes, key, GuessedIV.ShadowCopy(), 1);

            if (TestFileBytes != null && NetHasher.DotNetHasher.ComputeSHA1String(TestFileBytes).StartsWith(GuessedIV.ToHexString()))
            {
                LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", GuessedIV.ToHexString());
                return TestFileBytes;
            }

            return null;
        }

        private static byte[] CheckHCDBResult(byte[] EncryptedFileBytes, byte[] GuessedIV, byte[] key, ushort numOfSegments)
        {
            byte[] TestFileBytes;

            if (UseHCDBBruteforceShortcut)
                TestFileBytes = LIBSECURE.InitiateBlowfishBuffer(EncryptedFileBytes, key, GuessedIV.ShadowCopy(), "CTR", false, true).Result;
            else
                TestFileBytes = ToolsImplementation.ProcessCrypt_Decrypt(EncryptedFileBytes, key, GuessedIV.ShadowCopy(), 1);

            if (TestFileBytes != null && LZMA.SegmentsDecompress(TestFileBytes, false) != null)
            {
                LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0} (numOfSegments - {1})", DateTime.Now.ToString(), numOfSegments.ToString());
                LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", GuessedIV.ToHexString());
                return TestFileBytes;
            }

            return null;
        }

        private static byte[] CheckBARResult(byte[] EncryptedFileBytes, byte[] CipherTextReference, byte[] GuessedIV, byte[] key)
        {
            if (GuessedIV != null)
            {
                byte[] TestFileBytes = ToolsImplementation.ProcessCrypt_Decrypt(EncryptedFileBytes, key, GuessedIV.ShadowCopy(), 1);

                if (TestFileBytes != null && TestFileBytes.Length > 12 && ByteUtils.FindBytePattern(TestFileBytes, new byte[] { 0xAD, 0xEF, 0x17, 0xE1, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 }) != -1)
                {
                    LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                    LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", GuessedIV.ToHexString());
                    return TestFileBytes;
                }
                else
                {
                    GuessedIV = ProcessECBBuffer(XORBytes(CipherTextReference, BARFirst8BytesLittleEndianHeader), key);
                    if (GuessedIV != null)
                    {
                        TestFileBytes = ToolsImplementation.ProcessCrypt_Decrypt(EncryptedFileBytes, key, GuessedIV.ShadowCopy(), 1);

                        if (TestFileBytes != null && TestFileBytes.Length > 12 && ByteUtils.FindBytePattern(TestFileBytes, new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }) != -1)
                        {
                            LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                            LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", GuessedIV.ToHexString());
                            return TestFileBytes;
                        }
                        else
                        {
                            GuessedIV = ProcessECBBuffer(XORBytes(CipherTextReference, BARFirst8BytesBigEndianEquivHeader), key);
                            if (GuessedIV != null)
                            {
                                TestFileBytes = ToolsImplementation.ProcessCrypt_Decrypt(EncryptedFileBytes, key, GuessedIV.ShadowCopy(), 1);

                                if (TestFileBytes != null && TestFileBytes.Length > 12 && ByteUtils.FindBytePattern(TestFileBytes, new byte[] { 0xAD, 0xEF, 0x17, 0xE1, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }) != 1)
                                {
                                    LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                                    LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", GuessedIV.ToHexString());
                                    return TestFileBytes;
                                }
                                else
                                {
                                    GuessedIV = ProcessECBBuffer(XORBytes(CipherTextReference, BARFirst8BytesLittleEndianEquivHeader), key);
                                    if (GuessedIV != null)
                                    {
                                        TestFileBytes = ToolsImplementation.ProcessCrypt_Decrypt(EncryptedFileBytes, key, GuessedIV.ShadowCopy(), 1);

                                        if (TestFileBytes != null && TestFileBytes.Length > 12 && ByteUtils.FindBytePattern(TestFileBytes, new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }) != -1)
                                        {
                                            LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                                            LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", GuessedIV.ToHexString());
                                            return TestFileBytes;
                                        }
                                        else
                                        {
                                            GuessedIV = ProcessECBBuffer(XORBytes(CipherTextReference, BARFirst8BytesLittleEndianLeanZlibHeader), key);
                                            if (GuessedIV != null)
                                            {
                                                TestFileBytes = ToolsImplementation.ProcessCrypt_Decrypt(EncryptedFileBytes, key, GuessedIV.ShadowCopy(), 1);

                                                if (TestFileBytes != null && TestFileBytes.Length > 12 && ByteUtils.FindBytePattern(TestFileBytes, new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }) != -1)
                                                {
                                                    LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                                                    LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", GuessedIV.ToHexString());
                                                    return TestFileBytes;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return null;
        }

        private static byte[] ProcessECBBuffer(byte[] FileBytes, byte[] KeyBytes)
        {
            if (KeyBytes.Length == 32)
            {
                // Create the cipher
                IBufferedCipher cipher = CipherUtilities.GetCipher("Blowfish/ECB/NOPADDING");

                cipher.Init(false, new KeyParameter(KeyBytes));

                // Decrypt the ciphertext
                byte[] plaintextBytes = new byte[cipher.GetOutputSize(FileBytes.Length)];
                int ciphertextLength = cipher.ProcessBytes(FileBytes, 0, FileBytes.Length, plaintextBytes, 0);
                cipher.DoFinal(plaintextBytes, ciphertextLength);

                cipher = null;

                return plaintextBytes;
            }
            else
                LoggerAccessor.LogError("[CTRExploitProcess] - ProcessECBBuffer, Invalid KeyBytes or IV!");

            return null;
        }

        /// <summary>
        /// Apply a XOR mathematical calculation between 2 byte arrays.
        /// <para>Applique un calcul mathï¿½matique de type OU exclusif entre 2 tableaux de bytes.</para>
        /// </summary>
        /// <param name="array1">The left array.</param>
        /// <param name="array2">The right array.</param>
        /// <returns>A byte array.</returns>
        private static byte[] XORBytes(byte[] array1, byte[] array2)
        {
            return array1.Zip(array2, (x, y) => (byte)(x ^ y)).ToArray();
        }
    }
}
